
% calcolo pedine
free(X,Y):- cell(X,Y,C), C = 0.
enemy(X,Y):- cell(X,Y,C), C=1.
ally(I,X,Y):- cell(X,Y,C), C = 2, I=X*10+Y.

% Guess
move(I,X,Y) | notMove(I,X,Y) :- canMove(I,X,Y).

% movimenti 
canMove(I,X,Y):-canMoveO(I,X,Y).
canMove(I,X,Y):-canMoveS(I,X,Y).
canMove(I,X,Y):-canMoveN(I,X,Y).
canMove(I,X,Y):-canMoveE(I,X,Y).

%ovest
canMoveO(I,X,Z):- free(X,Z), ally(I,X,Y), Z=Y-1.
canMoveO(I,X,Z):- free(X,Z), canMoveO(I,X,Y), Z=Y-1, Z>=0.
PassiO(N,I):- #count{I,Y:canMoveO(I,_,Y)}=N,canMoveO(I,_,_).

%est
canMoveE(I,X,Z):- free(X,Z), ally(I,X,Y), Z=Y+1.
canMoveE(I,X,Z):- free(X,Z), canMoveE(I,X,Y), Z=Y+1, Z<=7.
PassiE(N,I):- #count{I,Y:canMoveE(I,_,Y)}=N,canMoveE(I,_,_).

%nord
canMoveN(I,Z,Y):- free(Z,Y), ally(I,X,Y), Z=X-1.
canMoveN(I,Z,Y):- free(Z,Y), canMoveN(I,X,Y), Z=X-1, Z>=0.
PassiN(N,I):- #count{I,X:canMoveN(I,X,_)}=N,canMoveN(I,_,_).

%sud
canMoveS(I,Z,Y):- free(Z,Y), ally(I,X,Y), Z=X+1.
canMoveS(I,Z,Y):- free(Z,Y), canMoveS(I,X,Y), Z=X+1, Z<=7.
PassiS(N,I):- #count{I,X:canMoveS(I,X,_)}=N,canMoveS(I,_,_).

%nemici vicini alla posizione libera
enemyNear(Z,X,Y):- #count{X,Y:enemy(X+1,Y)}=N, #count{X,Y:enemy(X-1,Y)}=S, 
                   #count{X,Y:enemy(X,Y+1)}=E, #count{X,Y:enemy(X,Y-1)}=O, free(X,Y), Z=N+S+E+O.

%alleati vicini ai nemici
allyNearEnemy(Z,X,Y):- #count{X,Y:ally(_,X+1,Y)}=N, #count{X,Y:ally(_,X-1,Y)}=S, 
                       #count{X,Y:ally(_,X,Y+1)}=E, #count{X,Y:ally(_,X,Y-1)}=O, enemy(X,Y), Z=N+S+E+O.

maxEnemyNear(Z,X,Y):- #max{C: enemyNear(C,_,_)}=Z, enemyNear(Z,X,Y).
minEnemyNear(Z,X,Y):- #min{C: enemyNear(C,_,_)}=Z, enemyNear(Z,X,Y).


%A livello più alto (3), cerchiamo di spostarci in una casella che permette di mangiare più pedine possibile
:~ notMove(I,X,Y), maxEnemyNear(Z,X,Y). [Z@3,X,Y]
:- move(I,X,Y), minEnemyNear(Z,X,Y).

%A livello 2, cerchiamo di NON spostarci in una casella che permette di mangiare una sola pedina nemica
:~ move(I,X,Y), enemyNear(N,X,Y), N<=1. [N@2]

%A livello 2 cerchiamo di scegliere la mossa che abbia più nemici vicini
:~ move(I1,C,D), move(I,A,B), enemyNear(V1,A,B), enemyNear(V2,C,D), V1>V2, C!=A , B!=D, I=I1. [V1@2]

%Cerchiamo di imporre che la mossa avvenga vicino un nemico che, a sua volta, ha un nostro alleato accanto
:~ move(I,A,B), move(I1,C,D), enemy(A,B+1), allyNearEnemy(Z,A,B+1), Z>0, enemy(C+1,D), allyNearEnemy(N,C+1,D), N=0, C!=A , B!=D, I==I1. [Z@3]
%:~ move(I,A,B), move(I1,C,D), enemy(A,B-1), allyNearEnemy(Z,A,B-1), Z>0, enemy(C+1,D), allyNearEnemy(N,C+1,D), N=0, C!=A , B!=D, I==I1. [Z@3]


%Non voglio che mi vengano restituiti più move.
%:- #count{I,X,Y : move(I,X,Y)}=N, N!=1.  

%Non vorrei che ti spostassi vicino un nemico se non ha vicino un alleato
%:~ move(I,A,B), enemy(A,B-1), allyNearEnemy(N,A,B-1), N=0.[N@1]

%:- move(I,X,Y), allyNearEnemy(N,X,Y+1), enemy(X,Y+1), N=0.%[1@1]
%:- move(I,X,Y), allyNearEnemy(X+1,Y), enemy(X+1,Y), N=0.%[1@1]
%:~ move(I,X,Y), not ally(X+2,Y), enemy(X+1,Y).[1@1]
%:~ move(I,X,Y), not ally(X,Y-2), enemy(X,Y-1).[1@1]
%:~ move(I,X,Y), not ally(X-2,Y), enemy(X-1,Y).[1@1]


%bestMove(I,A,B):- move(I,A,B), move(I,C,D), enemyNear(V2,A,B), enemyNear(V1,C,D), V2>V1, C!=A, B!=D.


%:-notMove(I,X,Y), ally(_,J,K), enemyNear(Z,J,K), Z>=1.